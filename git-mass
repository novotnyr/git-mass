#!/bin/sh

COMMAND="$1"
IGNORED_MODULES=$(cat .ignored_modules)

is_allowed() {
  for M in $IGNORED_MODULES
  do
    if [ "./$M/" = "$1" ]
    then
      return 1
    fi 
  done
}

die() {
    echo "$1"
    exit 1
}

switch_module_branch() {
	MODULE="$1"
	BRANCH="$3"
	
	[ "$BRANCH" ] || die "No branch was specified"
	
	cd "$MODULE" || return 
	git checkout "$BRANCH"
	echo "$MODULE switch to branch $BRANCH"
	cd .. 
}

git_pull_rebase() {
	MODULE="$1"
	cd "$MODULE" || return
	echo "Git Pull Rebase> $MODULE"
	git pull --rebase
	cd ..
}

full_merge() {
	MODULE="$1"
	shift 2
	OPTIND=""
	
	GIT_PUSH="true"
	COMMIT_MESSAGE_TEXT=""
	COMMIT_MESSAGE_PARAM="--log --no-edit -m"
	while getopts "pm:" OPT "$@"
	do
		case "$OPT" in
			p)
				GIT_PUSH="git push"
				;;
			m)
				COMMIT_MESSAGE_TEXT="$OPTARG"
				;;
			\?)
				echo "Invalid option -$OPT" >&2
				exit 1
				;;
			:)
				echo "Option $OPT requires an argument" >&2
				exit 1
				;;
		esac
	done
	eval SOURCE_BRANCH='$'$OPTIND
	eval TARGET_BRANCH='$'$(($OPTIND + 1))
	[ "$SOURCE_BRANCH" ] || die "No source branch was specified"
	[ "$TARGET_BRANCH" ] || die "No target branch was specified"
	
	cd "$MODULE" || return

	echo "----------------------------------------------"
	echo "Merge $SOURCE_BRANCH -> $TARGET_BRANCH> $MODULE"
	
	if [ -z "$COMMIT_MESSAGE_TEXT" ] 
	then
		COMMIT_MESSAGE_TEXT="Merge $SOURCE_BRANCH into $TARGET_BRANCH"
	fi
	
	git checkout "$TARGET_BRANCH" && \
		git branch --set-upstream-to=origin/"$TARGET_BRANCH" && \
			git pull --rebase &&  \
				git merge --no-ff $COMMIT_MESSAGE_PARAM "$COMMIT_MESSAGE_TEXT" "$SOURCE_BRANCH" && \
					"$GIT_PUSH" && \
						git checkout "$SOURCE_BRANCH"
	
	cd ..
}

last_commit_date() {
	MODULE="$1"
	BRANCH="$3"

	cd "$MODULE" || return

        [ "$BRANCH" ] || die "No branch was specified"

        LAST_COMMIT_DATE=$(git log --all --format="%ar;%d" | grep "$BRANCH" | cut -d";" -f1)
        printf "%-64s %s\n" "$MODULE" "$LAST_COMMIT_DATE"
        
        cd ..
}

list_module() {
	MODULE="$1"
	cd "$MODULE" || return
	
	pwd
	
	cd ..
}

reset_hard() {
	MODULE="$1"
	BRANCH="$3"
	
	cd "$MODULE" || return
	
	[ "$BRANCH" ] || die "No branch was specified" 
	
	echo "----------------------------------------------"
	echo "Resetting (hard) to branch $BRANCH > $MODULE"
	
	git reset --hard "$BRANCH"
	
	cd ..
}

execute_command() {
	MODULE="$1"
	
	cd "$MODULE" || return
	
	echo "----------------------------------------------"

	shift 2 # let's shift parameters to eat $MODULE and command name
	
	echo "$MODULE> git $@"
	
	git "$@"
	
	cd ..
}

[ "$COMMAND" ] || die "No command was specified"

for MODULE in ./*/
do
	if is_allowed "$MODULE"
	then
		case "$COMMAND" in
		list)
			list_module "$MODULE" "$@"
			;;
		checkout)
        		switch_module_branch "$MODULE" "$@"
        		;;
        	pull-rebase)
        		git_pull_rebase "$MODULE" "$@"
        		;;
        	full-merge)
        		full_merge "$MODULE" "$@"
        		;;
        	last-commit-date)
        		last_commit_date "$MODULE" "$@"
        		;;
        	reset-hard)
        		reset_hard "$MODULE" "$@"
        		;;
        	exec)
        		execute_command "$MODULE" "$@"
        		;;
        	*)
        		echo "Unknown command: $COMMAND"
        		exit 1
        		;;
        	esac
	fi
done
