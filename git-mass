#!/bin/sh

COMMAND="$1"
IGNORED_MODULES=$(cat .ignored_modules 2> /dev/null)

RED_COLOR='\033[0;31m'
GREEN_COLOR='\033[0;32m'
GRAY_COLOR='\033[0;2m'
NO_COLOR='\033[0m'

is_allowed() {
	for M in $IGNORED_MODULES
	do
		if [ "./$M/" = "$1" ]
		then
			return 1
		fi
	done
}

has_branch() {
	BRANCH="$1"
	[ "BRANCH" ] || die "No branch was specified"

	git rev-parse --quiet --verify "$BRANCH" > /dev/null
	return $?
}

die() {
	echo "$1"
	exit 1
}

switch_module_branch() {
	MODULE="$1"
	BRANCH="$3"
	
	[ "$BRANCH" ] || die "No branch was specified"

	cd "$MODULE" || return

	if has_branch "$BRANCH"
	then
		git checkout --quiet "$BRANCH"
		echo "$GREEN_COLOR$MODULE$NO_COLOR switched to $BRANCH"
	else
		echo "$GRAY_COLOR$MODULE$NO_COLOR> No branch $BRANCH"
	fi

	cd .. 
}

git_pull_rebase() {
	MODULE="$1"
	cd "$MODULE" || return
	echo "Git Pull Rebase> $MODULE"
	git pull --rebase
	cd ..
}

full_merge() {
	MODULE="$1"
	shift 2
	OPTIND=""
	
	GIT_PUSH="true"
	COMMIT_MESSAGE_TEXT=""
	COMMIT_MESSAGE_PARAM="--log --no-edit -m"
	while getopts "pm:" OPT "$@"
	do
		case "$OPT" in
			p)
				GIT_PUSH="git push"
				;;
			m)
				COMMIT_MESSAGE_TEXT="$OPTARG"
				;;
			\?)
				echo "Invalid option -$OPT" >&2
				exit 1
				;;
			:)
				echo "Option $OPT requires an argument" >&2
				exit 1
				;;
		esac
	done
	eval SOURCE_BRANCH='$'$OPTIND
	eval TARGET_BRANCH='$'$(($OPTIND + 1))
	[ "$SOURCE_BRANCH" ] || die "No source branch was specified"
	[ "$TARGET_BRANCH" ] || die "No target branch was specified"
	
	cd "$MODULE" || return

	echo "----------------------------------------------"
	echo "Merge $SOURCE_BRANCH -> $TARGET_BRANCH> $MODULE"
	
	if [ -z "$COMMIT_MESSAGE_TEXT" ] 
	then
		COMMIT_MESSAGE_TEXT="Merge $SOURCE_BRANCH into $TARGET_BRANCH"
	fi
	
	git checkout "$TARGET_BRANCH" && \
		git branch --set-upstream-to=origin/"$TARGET_BRANCH" && \
			git pull --rebase &&  \
				git merge --no-ff $COMMIT_MESSAGE_PARAM "$COMMIT_MESSAGE_TEXT" "$SOURCE_BRANCH" && \
					"$GIT_PUSH" && \
						git checkout "$SOURCE_BRANCH"
	
	cd ..
}

last_commit_date() {
	MODULE="$1"
	BRANCH="$3"

	cd "$MODULE" || return

	[ "$BRANCH" ] || die "No branch was specified"

	LAST_COMMIT_DATE=$(git log --all --format="%ar;%d" | grep "$BRANCH" | cut -d";" -f1)
	printf "%-64s %s\n" "$MODULE" "$LAST_COMMIT_DATE"

	cd ..
}

list_module() {
	MODULE="$1"
	cd "$MODULE" || return
	
	pwd
	
	cd ..
}

reset_hard() {
	MODULE="$1"
	BRANCH="$3"
	
	cd "$MODULE" || return
	
	[ "$BRANCH" ] || die "No branch was specified" 
	
	echo "----------------------------------------------"
	echo "Resetting (hard) to branch $BRANCH > $MODULE"
	
	git reset --hard "$BRANCH"
	
	cd ..
}

execute_command() {
	MODULE="$1"

	cd "$MODULE" || return

	echo "----------------------------------------------"

	shift 2 # let's shift parameters to eat $MODULE and command name

	echo "$MODULE> git $@"

	git "$@"

	cd ..
}

fwdiff() {
	MODULE="$1"
	cd "$MODULE" || return

	shift 2 # let's shift parameters to eat $MODULE and command name

	SOURCE_BRANCH="$1"
	TARGET_BRANCH="$2"
	VERBOSE="$3"
	
	[ "$SOURCE_BRANCH" ] || die "No source branch was specified"
	[ "$TARGET_BRANCH" ] || die "No target branch was specified"

	if ! has_branch "$SOURCE_BRANCH" || ! has_branch "$TARGET_BRANCH"
	then
		if [ "$VERBOSE" ]
		then
			echo "$MODULE> No branch $SOURCE_BRANCH" 2> /dev/null
		fi
		cd .. 
		return
	fi

	if git merge-base --is-ancestor "$SOURCE_BRANCH" "$TARGET_BRANCH"
	then
		if [ "$VERBOSE" ]
		then
			echo "$MODULE> No need to merge $SOURCE_BRANCH to $TARGET_BRANCH"
		fi
	else
		echo "$GREEN_COLOR$MODULE$NO_COLOR> $SOURCE_BRANCH is behind $TARGET_BRANCH"
	fi

	cd ..
}

diff_name_only() {
	MODULE="$1"
	cd "$MODULE" || return

	shift 2 # let's shift parameters to eat $MODULE and command name

	SOURCE_BRANCH="$1"
	TARGET_BRANCH="$2"
	VERBOSE="$3"

	[ "$SOURCE_BRANCH" ] || die "No source branch was specified"
	[ "$TARGET_BRANCH" ] || die "No target branch was specified"

	if ! has_branch "$SOURCE_BRANCH" || ! has_branch "$TARGET_BRANCH"
	then
		if [ "$VERBOSE" ]
		then
			echo "$MODULE> No branch $SOURCE_BRANCH" 2> /dev/null
		fi
		cd ..
		return
	fi

	DIFF_RESULT=$(git diff --name-only "$SOURCE_BRANCH" "$TARGET_BRANCH")
	if [ "$DIFF_RESULT" ]
	then
		DIFF_RESULT=$(echo "$DIFF_RESULT" | xargs printf "\t%s\n")
		echo "$GREEN_COLOR$MODULE$NO_COLOR>"
		echo "$DIFF_RESULT"
	else
		[ "$VERBOSE" ] && echo "$GRAY_COLOR$MODULE$NO_COLOR> No diff"
	fi

	cd ..
}

# Remove a branch that has no changes or diffs with
# the source branch.
cleanup_unchanged_branches() {
	MODULE="$1"
	cd "$MODULE" || return

	shift 2 # let's shift parameters to eat $MODULE and command name

	SOURCE_BRANCH="$1"
	TARGET_BRANCH="$2"
	VERBOSE="$3"

	[ "$SOURCE_BRANCH" ] || die "No source branch was specified"
	[ "$TARGET_BRANCH" ] || die "No target branch was specified"

	if ! has_branch "$SOURCE_BRANCH" || ! has_branch "$TARGET_BRANCH"
	then
		if [ "$VERBOSE" ]
		then
			echo "$MODULE> No branch $SOURCE_BRANCH" 2> /dev/null
		fi
		cd ..
		return
	fi

	DIFF_RESULT=$(git diff --name-only "$SOURCE_BRANCH" "$TARGET_BRANCH")
	if [ -z "$DIFF_RESULT" ]
	then
		# read does not support color codes. We print colored message without \n
		printf "$GREEN_COLOR$MODULE$NO_COLOR> $TARGET_BRANCH has no differences with $SOURCE_BRANCH."
		read -p "Type 'y' to delete it> " INPUT
		if [ "y" = "$INPUT" ]
		then
			git checkout "$SOURCE_BRANCH"
			git branch -d "$TARGET_BRANCH"
		else
			echo "$MODULE> $TARGET_BRANCH left intact"
		fi
	fi

	cd ..
}

[ "$COMMAND" ] || die "No command was specified"

for MODULE in ./*/
do
	[ -d "$MODULE" ] || die "No module subdirectories. Nothing to do"

	if is_allowed "$MODULE"
	then
		case "$COMMAND" in
		list)
			list_module "$MODULE" "$@"
			;;
		checkout)
			switch_module_branch "$MODULE" "$@"
			;;
		pull-rebase)
			git_pull_rebase "$MODULE" "$@"
			;;
		full-merge)
			full_merge "$MODULE" "$@"
			;;
		last-commit-date)
			last_commit_date "$MODULE" "$@"
			;;
		reset-hard)
			reset_hard "$MODULE" "$@"
			;;
		fwdiff)
			fwdiff "$MODULE" "$@"
			;;
		namediff)
			diff_name_only "$MODULE" "$@"
			;;
		cleanup-unchanged-brances)
			cleanup_unchanged_branches "$MODULE" "$@"
			;;
		cub)
			cleanup_unchanged_branches "$MODULE" "$@"
			;;
		exec)
			execute_command "$MODULE" "$@"
			;;
		*)
			echo "Unknown command: $COMMAND"
			exit 1
			;;
        esac
	fi
done
