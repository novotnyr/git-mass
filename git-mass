#!/bin/sh
COMMAND="$1"
IGNORED_MODULES=$(cat .ignored_modules 2> /dev/null)

RED_COLOR='\033[0;31m'
GREEN_COLOR='\033[0;32m'
GRAY_COLOR='\033[0;2m'
NO_COLOR='\033[0m'

is_allowed() {
	for M in $IGNORED_MODULES
	do
		if [ "./$M/" = "$1" ]
		then
			return 1
		fi
	done
}

has_branch() {
	BRANCH="$1"
	[ "$BRANCH" ] || die "No branch was specified"

	git rev-parse --quiet --verify "$BRANCH" > /dev/null
	return $?
}

die() {
	echo "$1"
	exit 1
}

# Executed before switching directory to a module, as many times as there are modules.
#
# Parameters:
#	1: module name
_before_module() {
    MODULE="$1"
	if [ -d "$MODULE/.git" ]
	then
		cd "$MODULE" || return 1
		return
	else
		echo "$GRAY_COLOR$MODULE$NO_COLOR> not a Git repo"
		return 2
	fi
}

# Executed after switching directory to a module, as many times as there are
# modules.
#
# Parameters:
#	none
_after_module() {
	cd .. || return 1
}

cmd_switch_module_branch() {
	MODULE="$1"
	shift
	BRANCH="$2"

	[ "$BRANCH" ] || die "No branch was specified"

	if has_branch "$BRANCH"
	then
		git checkout --quiet "$BRANCH"
		echo "$GREEN_COLOR$MODULE$NO_COLOR switched to $BRANCH"
	else
		echo "$GRAY_COLOR$MODULE$NO_COLOR> No branch $BRANCH"
	fi
}

switch_module_branch() {
	MODULE="$1"
	BRANCH="$3"
	
	[ "$BRANCH" ] || die "No branch was specified"

	cd "$MODULE" || return

	if has_branch "$BRANCH"
	then
		git checkout --quiet "$BRANCH"
		echo "$GREEN_COLOR$MODULE$NO_COLOR switched to $BRANCH"
	else
		echo "$GRAY_COLOR$MODULE$NO_COLOR> No branch $BRANCH"
	fi

	cd .. 
}

pull_rebase() {
	MODULE="$1"
	shift 2 # let's shift parameters to eat $MODULE and command name
	cd "$MODULE" || return
	RESULT=$(git pull --rebase)
	echo "$GREEN_COLOR$MODULE$NO_COLOR> $RESULT"
	cd ..
}

full_merge() {
	MODULE="$1"
	shift 2
	OPTIND=""
	
	GIT_PUSH="true"
	COMMIT_MESSAGE_TEXT=""
	COMMIT_MESSAGE_PARAM="--log --no-edit -m"
	while getopts "pm:" OPT "$@"
	do
		case "$OPT" in
			p)
				GIT_PUSH="git push"
				;;
			m)
				COMMIT_MESSAGE_TEXT="$OPTARG"
				;;
			\?)
				echo "Invalid option -$OPT" >&2
				exit 1
				;;
			:)
				echo "Option $OPT requires an argument" >&2
				exit 1
				;;
		esac
	done
	eval SOURCE_BRANCH='$'$OPTIND
	eval TARGET_BRANCH='$'$(($OPTIND + 1))
	[ "$SOURCE_BRANCH" ] || die "No source branch was specified"
	[ "$TARGET_BRANCH" ] || die "No target branch was specified"
	
	cd "$MODULE" || return

	echo "----------------------------------------------"
	echo "Merge $SOURCE_BRANCH -> $TARGET_BRANCH> $MODULE"
	
	if [ -z "$COMMIT_MESSAGE_TEXT" ] 
	then
		COMMIT_MESSAGE_TEXT="Merge $SOURCE_BRANCH into $TARGET_BRANCH"
	fi
	
	git checkout "$TARGET_BRANCH" && \
		git branch --set-upstream-to=origin/"$TARGET_BRANCH" && \
			git pull --rebase &&  \
				git merge --no-ff $COMMIT_MESSAGE_PARAM "$COMMIT_MESSAGE_TEXT" "$SOURCE_BRANCH" && \
					"$GIT_PUSH" && \
						git checkout "$SOURCE_BRANCH"
	
	cd ..
}

last_commit_date() {
	MODULE="$1"
	BRANCH="$3"

	cd "$MODULE" || return

	[ "$BRANCH" ] || die "No branch was specified"

	LAST_COMMIT_DATE=$(git log --all --format="%ar;%d" | grep "$BRANCH" | cut -d";" -f1)
	printf "%-64s %s\n" "$MODULE" "$LAST_COMMIT_DATE"

	cd ..
}

list_module() {
	MODULE="$1"
	cd "$MODULE" || return
	
	pwd
	
	cd ..
}

reset_hard() {
	MODULE="$1"
	BRANCH="$3"
	
	cd "$MODULE" || return
	
	[ "$BRANCH" ] || die "No branch was specified" 
	
	echo "----------------------------------------------"
	echo "Resetting (hard) to branch $BRANCH > $MODULE"
	
	git reset --hard "$BRANCH"
	
	cd ..
}

execute_command() {
	MODULE="$1"

	cd "$MODULE" || return

	echo "----------------------------------------------"

	shift 2 # let's shift parameters to eat $MODULE and command name

	echo "$MODULE> git $@"

	git "$@"

	cd ..
}

fwdiff() {
	MODULE="$1"
	cd "$MODULE" || return

	shift 2 # let's shift parameters to eat $MODULE and command name

	SOURCE_BRANCH="$1"
	TARGET_BRANCH="$2"
	VERBOSE="$3"
	
	[ "$SOURCE_BRANCH" ] || die "No source branch was specified"
	[ "$TARGET_BRANCH" ] || die "No target branch was specified"

	if ! has_branch "$SOURCE_BRANCH" || ! has_branch "$TARGET_BRANCH"
	then
		if [ "$VERBOSE" ]
		then
			echo "$MODULE> No branch $SOURCE_BRANCH" 2> /dev/null
		fi
		cd .. 
		return
	fi

	if git merge-base --is-ancestor "$SOURCE_BRANCH" "$TARGET_BRANCH"
	then
		if [ "$VERBOSE" ]
		then
			echo "$MODULE> No need to merge $SOURCE_BRANCH to $TARGET_BRANCH"
		fi
	else
		echo "$GREEN_COLOR$MODULE$NO_COLOR> $SOURCE_BRANCH is behind $TARGET_BRANCH"
	fi

	cd ..
}

diff_name_only() {
	MODULE="$1"
	cd "$MODULE" || return

	shift 2 # let's shift parameters to eat $MODULE and command name

	SOURCE_BRANCH="$1"
	TARGET_BRANCH="$2"
	VERBOSE="$3"

	[ "$SOURCE_BRANCH" ] || die "No source branch was specified"
	[ "$TARGET_BRANCH" ] || die "No target branch was specified"

	if ! has_branch "$SOURCE_BRANCH" || ! has_branch "$TARGET_BRANCH"
	then
		if [ "$VERBOSE" ]
		then
			echo "$MODULE> No branch $SOURCE_BRANCH" 2> /dev/null
		fi
		cd ..
		return
	fi

	DIFF_RESULT=$(git diff --name-only "$SOURCE_BRANCH" "$TARGET_BRANCH")
	if [ "$DIFF_RESULT" ]
	then
		DIFF_RESULT=$(echo "$DIFF_RESULT" | xargs printf "\t%s\n")
		echo "$GREEN_COLOR$MODULE$NO_COLOR>"
		echo "$DIFF_RESULT"
	else
		[ "$VERBOSE" ] && echo "$GRAY_COLOR$MODULE$NO_COLOR> No diff"
	fi

	cd ..
}

# Remove a branch that has no changes or diffs with
# the source branch.
cleanup_unchanged_branches() {
	MODULE="$1"
	cd "$MODULE" || return

	shift 2 # let's shift parameters to eat $MODULE and command name

	SOURCE_BRANCH="$1"
	TARGET_BRANCH="$2"
	VERBOSE="$3"

	[ "$SOURCE_BRANCH" ] || die "No source branch was specified"
	[ "$TARGET_BRANCH" ] || die "No target branch was specified"

	if ! has_branch "$SOURCE_BRANCH" || ! has_branch "$TARGET_BRANCH"
	then
		if [ "$VERBOSE" ]
		then
			echo "$MODULE> No branch $SOURCE_BRANCH" 2> /dev/null
		fi
		cd ..
		return
	fi

	DIFF_RESULT=$(git diff --name-only "$SOURCE_BRANCH" "$TARGET_BRANCH")
	if [ -z "$DIFF_RESULT" ]
	then
		# read does not support color codes. We print colored message without \n
		printf "$GREEN_COLOR$MODULE$NO_COLOR> $TARGET_BRANCH has no differences with $SOURCE_BRANCH."
		read -p "Type 'y' to delete it> " INPUT
		if [ "y" = "$INPUT" ]
		then
			git checkout "$SOURCE_BRANCH"
			git branch -d "$TARGET_BRANCH"
		else
			echo "$MODULE> $TARGET_BRANCH left intact"
		fi
	fi

	cd ..
}

grep_string() {
	MODULE="$1"
	cd "$MODULE" || return

	shift 2 # let's shift parameters to eat $MODULE and command name

	REGEXP="$1"

	GIT_LOG=$(git log --all --regexp-ignore-case --pretty=oneline --grep="$REGEXP")
	if [ "$GIT_LOG" ]
	then
		printf "$GREEN_COLOR$MODULE$NO_COLOR>\n"
		GIT_LOG=$(echo "$GIT_LOG" | xargs -I{} printf '\t%s\n' {})
		echo "$GIT_LOG"
	fi

	cd ..
}

update_all_remote_branches() {
	MODULE="$1"

	cd "$MODULE" || return

	shift 2 # let's shift parameters to eat $MODULE and command name

	git fetch --all > /dev/null || die "Unable to fetch all remote branches"

	# maintain a list of already tracked branches
	ALREADY_TRACKED_BRANCHES=""
	# lists all remotes, except entries like 'origin/HEAD -> origin/master'
	for REMOTE_BRANCH in $(git branch --remote | grep -Fv ' -> ')
	do
		LOCAL_BRANCH="${REMOTE_BRANCH#*/}"
		if has_branch "$LOCAL_BRANCH"
		then
			ALREADY_TRACKED_BRANCHES="$ALREADY_TRACKED_BRANCHES $LOCAL_BRANCH"
		else
			git branch "$LOCAL_BRANCH" --track "$REMOTE_BRANCH"
		fi
	done

	if [ "$ALREADY_TRACKED_BRANCHES" ]
	then
		echo "$GREEN_COLOR$MODULE$NO_COLOR> Already tracked: $ALREADY_TRACKED_BRANCHES"
	fi

	cd ..
}

[ "$COMMAND" ] || die "No command was specified"

# Flag that the command was handled and it is not necessary to process it in a
# legacy way
CMD_HANDLED=""
for MODULE in ./*/
do
	[ -d "$MODULE" ] || die "No module subdirectories. Nothing to do"

	if _before_module "$MODULE"
	then
		case "$COMMAND" in
		checkout)
			cmd_switch_module_branch "$MODULE" "$@"
			CMD_HANDLED=true
			;;
		esac

		_after_module
	fi
done

if [ "$CMD_HANDLED" ]
then
	exit 0
fi


for MODULE in ./*/
do
	[ -d "$MODULE" ] || die "No module subdirectories. Nothing to do"

	if is_allowed "$MODULE"
	then
		case "$COMMAND" in
		list)
			list_module "$MODULE" "$@"
			;;
		pull-rebase)
			pull_rebase "$MODULE" "$@"
			;;
		full-merge)
			full_merge "$MODULE" "$@"
			;;
		last-commit-date)
			last_commit_date "$MODULE" "$@"
			;;
		reset-hard)
			reset_hard "$MODULE" "$@"
			;;
		fwdiff)
			fwdiff "$MODULE" "$@"
			;;
		dirdiff)
			diff_name_only "$MODULE" "$@"
			;;
		namediff)
			diff_name_only "$MODULE" "$@"
			;;
		cleanup-unchanged-brances)
			cleanup_unchanged_branches "$MODULE" "$@"
			;;
		cub)
			cleanup_unchanged_branches "$MODULE" "$@"
			;;
		grep)
			grep_string "$MODULE" "$@"
			;;
		uarb)
			update_all_remote_branches "$MODULE" "$@"
			;;
		update-all-remote-branches)
			update_all_remote_branches "$MODULE" "$@"
			;;
		exec)
			execute_command "$MODULE" "$@"
			;;
		*)
			echo "Unknown command: $COMMAND"
			exit 1
			;;
        esac
	fi
done
